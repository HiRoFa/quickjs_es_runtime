<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `Lexer` trait in crate `swc_ecma_lexer`."><title>Lexer in swc_ecma_lexer::common::lexer - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-84e720fa.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="swc_ecma_lexer" data-themes="" data-resource-suffix="" data-rustdoc-version="1.89.0 (29483883e 2025-08-04)" data-channel="1.89.0" data-search-js="search-92309212.js" data-settings-js="settings-5514c975.js" ><script src="../../../static.files/storage-4e99c027.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-fd3af306.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../swc_ecma_lexer/index.html">swc_<wbr>ecma_<wbr>lexer</a><span class="version">23.0.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Lexer</a></h2><h3><a href="#required-associated-types">Required Associated Types</a></h3><ul class="block"><li><a href="#associatedtype.CommentsBuffer" title="CommentsBuffer">CommentsBuffer</a></li><li><a href="#associatedtype.State" title="State">State</a></li><li><a href="#associatedtype.Token" title="Token">Token</a></li></ul><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.atom" title="atom">atom</a></li><li><a href="#tymethod.comments" title="comments">comments</a></li><li><a href="#tymethod.comments_buffer" title="comments_buffer">comments_buffer</a></li><li><a href="#tymethod.comments_buffer_mut" title="comments_buffer_mut">comments_buffer_mut</a></li><li><a href="#tymethod.input" title="input">input</a></li><li><a href="#tymethod.input_mut" title="input_mut">input_mut</a></li><li><a href="#tymethod.input_slice" title="input_slice">input_slice</a></li><li><a href="#tymethod.input_uncons_while" title="input_uncons_while">input_uncons_while</a></li><li><a href="#tymethod.push_error" title="push_error">push_error</a></li><li><a href="#tymethod.state" title="state">state</a></li><li><a href="#tymethod.state_mut" title="state_mut">state_mut</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.bump" title="bump">bump</a></li><li><a href="#method.consume_pending_comments" title="consume_pending_comments">consume_pending_comments</a></li><li><a href="#method.cur" title="cur">cur</a></li><li><a href="#method.cur_pos" title="cur_pos">cur_pos</a></li><li><a href="#method.eat" title="eat">eat</a></li><li><a href="#method.emit_error" title="emit_error">emit_error</a></li><li><a href="#method.emit_error_span" title="emit_error_span">emit_error_span</a></li><li><a href="#method.emit_module_mode_error" title="emit_module_mode_error">emit_module_mode_error</a></li><li><a href="#method.emit_strict_mode_error" title="emit_strict_mode_error">emit_strict_mode_error</a></li><li><a href="#method.ensure_not_ident" title="ensure_not_ident">ensure_not_ident</a></li><li><a href="#method.error" title="error">error</a></li><li><a href="#method.error_span" title="error_span">error_span</a></li><li><a href="#method.had_line_break_before_last" title="had_line_break_before_last">had_line_break_before_last</a></li><li><a href="#method.is" title="is">is</a></li><li><a href="#method.is_str" title="is_str">is_str</a></li><li><a href="#method.last_pos" title="last_pos">last_pos</a></li><li><a href="#method.make_legacy_octal" title="make_legacy_octal">make_legacy_octal</a></li><li><a href="#method.peek" title="peek">peek</a></li><li><a href="#method.peek_ahead" title="peek_ahead">peek_ahead</a></li><li><a href="#method.read_digits" title="read_digits">read_digits</a></li><li><a href="#method.read_escaped_char" title="read_escaped_char">read_escaped_char</a></li><li><a href="#method.read_ident_unknown" title="read_ident_unknown">read_ident_unknown</a></li><li><a href="#method.read_int_u32" title="read_int_u32">read_int_u32</a></li><li><a href="#method.read_jsx_entity" title="read_jsx_entity">read_jsx_entity</a></li><li><a href="#method.read_jsx_new_line" title="read_jsx_new_line">read_jsx_new_line</a></li><li><a href="#method.read_jsx_str" title="read_jsx_str">read_jsx_str</a></li><li><a href="#method.read_jsx_word" title="read_jsx_word">read_jsx_word</a></li><li><a href="#method.read_keyword_as_str_with" title="read_keyword_as_str_with">read_keyword_as_str_with</a></li><li><a href="#method.read_keyword_with" title="read_keyword_with">read_keyword_with</a></li><li><a href="#method.read_number" title="read_number">read_number</a></li><li><a href="#method.read_number_no_dot_as_str" title="read_number_no_dot_as_str">read_number_no_dot_as_str</a></li><li><a href="#method.read_radix_number" title="read_radix_number">read_radix_number</a></li><li><a href="#method.read_regexp" title="read_regexp">read_regexp</a></li><li><a href="#method.read_shebang" title="read_shebang">read_shebang</a></li><li><a href="#method.read_slash" title="read_slash">read_slash</a></li><li><a href="#method.read_str_lit" title="read_str_lit">read_str_lit</a></li><li><a href="#method.read_tmpl_token" title="read_tmpl_token">read_tmpl_token</a></li><li><a href="#method.read_token_colon" title="read_token_colon">read_token_colon</a></li><li><a href="#method.read_token_dot" title="read_token_dot">read_token_dot</a></li><li><a href="#method.read_token_logical" title="read_token_logical">read_token_logical</a></li><li><a href="#method.read_token_mul_mod" title="read_token_mul_mod">read_token_mul_mod</a></li><li><a href="#method.read_token_number_sign" title="read_token_number_sign">read_token_number_sign</a></li><li><a href="#method.read_token_question_mark" title="read_token_question_mark">read_token_question_mark</a></li><li><a href="#method.read_token_zero" title="read_token_zero">read_token_zero</a></li><li><a href="#method.read_unicode_escape" title="read_unicode_escape">read_unicode_escape</a></li><li><a href="#method.read_word_as_str_with" title="read_word_as_str_with">read_word_as_str_with</a></li><li><a href="#method.read_word_as_str_with_slow_path" title="read_word_as_str_with_slow_path">read_word_as_str_with_slow_path</a></li><li><a href="#method.skip_block_comment" title="skip_block_comment">skip_block_comment</a></li><li><a href="#method.skip_line_comment" title="skip_line_comment">skip_line_comment</a></li><li><a href="#method.skip_space" title="skip_space">skip_space</a></li><li><a href="#method.span" title="span">span</a></li></ul><h3><a href="#dyn-compatibility">Dyn Compatibility</a></h3><h3><a href="#implementors">Implementors</a></h3></section><div id="rustdoc-modnav"><h2><a href="index.html">In swc_<wbr>ecma_<wbr>lexer::<wbr>common::<wbr>lexer</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">swc_ecma_lexer</a>::<wbr><a href="../index.html">common</a>::<wbr><a href="index.html">lexer</a></div><h1>Trait <span class="trait">Lexer</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#77-2147">Source</a> </span></div><pre class="rust item-decl"><code>pub trait Lexer&lt;'a, TokenAndSpan&gt;: <a class="trait" href="../input/trait.Tokens.html" title="trait swc_ecma_lexer::common::input::Tokens">Tokens</a>&lt;TokenAndSpan&gt; + <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> {
    type <a href="#associatedtype.State" class="associatedtype">State</a>: <a class="trait" href="state/trait.State.html" title="trait swc_ecma_lexer::common::lexer::state::State">State</a>;
    type <a href="#associatedtype.Token" class="associatedtype">Token</a>: <a class="trait" href="token/trait.TokenFactory.html" title="trait swc_ecma_lexer::common::lexer::token::TokenFactory">TokenFactory</a>&lt;'a, TokenAndSpan, Self, Lexer = Self&gt;;
    type <a href="#associatedtype.CommentsBuffer" class="associatedtype">CommentsBuffer</a>: <a class="trait" href="comments_buffer/trait.CommentsBufferTrait.html" title="trait swc_ecma_lexer::common::lexer::comments_buffer::CommentsBufferTrait">CommentsBufferTrait</a>;

<details class="toggle type-contents-toggle"><summary class="hideme"><span>Show 62 methods</span></summary>    // Required methods
    fn <a href="#tymethod.input" class="fn">input</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../struct.StringInput.html" title="struct swc_ecma_lexer::StringInput">StringInput</a>&lt;'a&gt;;
<span class="item-spacer"></span>    fn <a href="#tymethod.input_mut" class="fn">input_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../../struct.StringInput.html" title="struct swc_ecma_lexer::StringInput">StringInput</a>&lt;'a&gt;;
<span class="item-spacer"></span>    fn <a href="#tymethod.state" class="fn">state</a>(&amp;self) -&gt; &amp;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.State" title="type swc_ecma_lexer::common::lexer::Lexer::State">State</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.state_mut" class="fn">state_mut</a>(&amp;mut self) -&gt; &amp;mut Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.State" title="type swc_ecma_lexer::common::lexer::Lexer::State">State</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.comments" class="fn">comments</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'a dyn <a class="trait" href="../../../swc_common/comments/trait.Comments.html" title="trait swc_common::comments::Comments">Comments</a>&gt;;
<span class="item-spacer"></span>    fn <a href="#tymethod.comments_buffer" class="fn">comments_buffer</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.CommentsBuffer" title="type swc_ecma_lexer::common::lexer::Lexer::CommentsBuffer">CommentsBuffer</a>&gt;;
<span class="item-spacer"></span>    fn <a href="#tymethod.comments_buffer_mut" class="fn">comments_buffer_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.CommentsBuffer" title="type swc_ecma_lexer::common::lexer::Lexer::CommentsBuffer">CommentsBuffer</a>&gt;;
<span class="item-spacer"></span>    unsafe fn <a href="#tymethod.input_slice" class="fn">input_slice</a>(&amp;mut self, start: <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a>, end: <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a>) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.str.html">str</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.input_uncons_while" class="fn">input_uncons_while</a>(&amp;mut self, f: impl <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.str.html">str</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.atom" class="fn">atom</a>&lt;'b&gt;(&amp;self, s: impl <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.89.0/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'b, <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.str.html">str</a>&gt;&gt;) -&gt; <a class="struct" href="../../../swc_atoms/struct.Atom.html" title="struct swc_atoms::Atom">Atom</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.push_error" class="fn">push_error</a>(&amp;mut self, error: <a class="struct" href="../../error/struct.Error.html" title="struct swc_ecma_lexer::error::Error">Error</a>);

    // Provided methods
    fn <a href="#method.had_line_break_before_last" class="fn">had_line_break_before_last</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.span" class="fn">span</a>(&amp;self, start: <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a>) -&gt; <a class="struct" href="../../../swc_common/syntax_pos/struct.Span.html" title="struct swc_common::syntax_pos::Span">Span</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.bump" class="fn">bump</a>(&amp;mut self) { ... }
<span class="item-spacer"></span>    fn <a href="#method.is" class="fn">is</a>(&amp;self, c: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u8.html">u8</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.is_str" class="fn">is_str</a>(&amp;self, s: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.eat" class="fn">eat</a>(&amp;mut self, c: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u8.html">u8</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.cur" class="fn">cur</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.char.html">char</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.peek" class="fn">peek</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.char.html">char</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.peek_ahead" class="fn">peek_ahead</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.char.html">char</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.cur_pos" class="fn">cur_pos</a>(&amp;self) -&gt; <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.last_pos" class="fn">last_pos</a>(&amp;self) -&gt; <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.error" class="fn">error</a>&lt;T&gt;(&amp;self, start: <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a>, kind: <a class="enum" href="../../error/enum.SyntaxError.html" title="enum swc_ecma_lexer::error::SyntaxError">SyntaxError</a>) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;T&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.error_span" class="fn">error_span</a>&lt;T&gt;(&amp;self, span: <a class="struct" href="../../../swc_common/syntax_pos/struct.Span.html" title="struct swc_common::syntax_pos::Span">Span</a>, kind: <a class="enum" href="../../error/enum.SyntaxError.html" title="enum swc_ecma_lexer::error::SyntaxError">SyntaxError</a>) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;T&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.emit_error" class="fn">emit_error</a>(&amp;mut self, start: <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a>, kind: <a class="enum" href="../../error/enum.SyntaxError.html" title="enum swc_ecma_lexer::error::SyntaxError">SyntaxError</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.emit_error_span" class="fn">emit_error_span</a>(&amp;mut self, span: <a class="struct" href="../../../swc_common/syntax_pos/struct.Span.html" title="struct swc_common::syntax_pos::Span">Span</a>, kind: <a class="enum" href="../../error/enum.SyntaxError.html" title="enum swc_ecma_lexer::error::SyntaxError">SyntaxError</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.emit_strict_mode_error" class="fn">emit_strict_mode_error</a>(&amp;mut self, start: <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a>, kind: <a class="enum" href="../../error/enum.SyntaxError.html" title="enum swc_ecma_lexer::error::SyntaxError">SyntaxError</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.emit_module_mode_error" class="fn">emit_module_mode_error</a>(&amp;mut self, start: <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a>, kind: <a class="enum" href="../../error/enum.SyntaxError.html" title="enum swc_ecma_lexer::error::SyntaxError">SyntaxError</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.skip_line_comment" class="fn">skip_line_comment</a>(&amp;mut self, start_skip: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.usize.html">usize</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.skip_block_comment" class="fn">skip_block_comment</a>(&amp;mut self) { ... }
<span class="item-spacer"></span>    fn <a href="#method.skip_space" class="fn">skip_space</a>&lt;const LEX_COMMENTS: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>&gt;(&amp;mut self) { ... }
<span class="item-spacer"></span>    fn <a href="#method.ensure_not_ident" class="fn">ensure_not_ident</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.unit.html">()</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.make_legacy_octal" class="fn">make_legacy_octal</a>(&amp;mut self, start: <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a>, val: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.f64.html">f64</a>) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.f64.html">f64</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_digits" class="fn">read_digits</a>&lt;F, Ret, const RADIX: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u8.html">u8</a>&gt;(
        &amp;mut self,
        op: F,
        allow_num_separator: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>,
        has_underscore: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>,
    ) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Ret&gt;
       <span class="where">where F: <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Ret, <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u8.html">u8</a>, <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u32.html">u32</a>) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;(Ret, <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>)&gt;,
             Ret: <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> + <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_number_no_dot_as_str" class="fn">read_number_no_dot_as_str</a>&lt;const RADIX: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u8.html">u8</a>&gt;(
        &amp;mut self,
    ) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;<a class="struct" href="number/struct.LazyInteger.html" title="struct swc_ecma_lexer::common::lexer::number::LazyInteger">LazyInteger</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_number" class="fn">read_number</a>&lt;const START_WITH_DOT: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>, const START_WITH_ZERO: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>&gt;(
        &amp;mut self,
    ) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;<a class="enum" href="../../../either/enum.Either.html" title="enum either::Either">Either</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.f64.html">f64</a>, <a class="struct" href="../../../swc_atoms/struct.Atom.html" title="struct swc_atoms::Atom">Atom</a>), (<a class="struct" href="https://doc.rust-lang.org/1.89.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="struct" href="../../../num_bigint/bigint/struct.BigInt.html" title="struct num_bigint::bigint::BigInt">BigIntValue</a>&gt;, <a class="struct" href="../../../swc_atoms/struct.Atom.html" title="struct swc_atoms::Atom">Atom</a>)&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_int_u32" class="fn">read_int_u32</a>&lt;const RADIX: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u8.html">u8</a>&gt;(
        &amp;mut self,
        len: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u8.html">u8</a>,
    ) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u32.html">u32</a>&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_radix_number" class="fn">read_radix_number</a>&lt;const RADIX: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u8.html">u8</a>&gt;(
        &amp;mut self,
    ) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;<a class="enum" href="../../../either/enum.Either.html" title="enum either::Either">Either</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.f64.html">f64</a>, <a class="struct" href="../../../swc_atoms/struct.Atom.html" title="struct swc_atoms::Atom">Atom</a>), (<a class="struct" href="https://doc.rust-lang.org/1.89.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="struct" href="../../../num_bigint/bigint/struct.BigInt.html" title="struct num_bigint::bigint::BigInt">BigIntValue</a>&gt;, <a class="struct" href="../../../swc_atoms/struct.Atom.html" title="struct swc_atoms::Atom">Atom</a>)&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.consume_pending_comments" class="fn">consume_pending_comments</a>(&amp;mut self) { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_jsx_word" class="fn">read_jsx_word</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_jsx_entity" class="fn">read_jsx_entity</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.char.html">char</a>, <a class="struct" href="https://doc.rust-lang.org/1.89.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>)&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_jsx_new_line" class="fn">read_jsx_new_line</a>(
        &amp;mut self,
        normalize_crlf: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>,
    ) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;<a class="enum" href="../../../either/enum.Either.html" title="enum either::Either">Either</a>&lt;&amp;'static <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.str.html">str</a>, <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.char.html">char</a>&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_jsx_str" class="fn">read_jsx_str</a>(&amp;mut self, quote: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.char.html">char</a>) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_unicode_escape" class="fn">read_unicode_escape</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.89.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="char/struct.Char.html" title="struct swc_ecma_lexer::common::lexer::char::Char">Char</a>&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_shebang" class="fn">read_shebang</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../../swc_atoms/struct.Atom.html" title="struct swc_atoms::Atom">Atom</a>&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_tmpl_token" class="fn">read_tmpl_token</a>(
        &amp;mut self,
        start_of_tpl: <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a>,
    ) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_escaped_char" class="fn">read_escaped_char</a>(
        &amp;mut self,
        in_template: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>,
    ) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.89.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="char/struct.Char.html" title="struct swc_ecma_lexer::common::lexer::char::Char">Char</a>&gt;&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_regexp" class="fn">read_regexp</a>(&amp;mut self, start: <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a>) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_word_as_str_with" class="fn">read_word_as_str_with</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;(<a class="enum" href="https://doc.rust-lang.org/1.89.0/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.str.html">str</a>&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>)&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_word_as_str_with_slow_path" class="fn">read_word_as_str_with_slow_path</a>(
        &amp;mut self,
        slice_start: <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a>,
    ) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;(<a class="enum" href="https://doc.rust-lang.org/1.89.0/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.str.html">str</a>&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>)&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_token_number_sign" class="fn">read_token_number_sign</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_token_dot" class="fn">read_token_dot</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_token_question_mark" class="fn">read_token_question_mark</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_token_colon" class="fn">read_token_colon</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_token_zero" class="fn">read_token_zero</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_token_logical" class="fn">read_token_logical</a>&lt;const C: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u8.html">u8</a>&gt;(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_token_mul_mod" class="fn">read_token_mul_mod</a>(&amp;mut self, is_mul: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_slash" class="fn">read_slash</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_ident_unknown" class="fn">read_ident_unknown</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_str_lit" class="fn">read_str_lit</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_keyword_with" class="fn">read_keyword_with</a>(
        &amp;mut self,
        convert: &amp;dyn <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(&amp;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt;,
    ) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_keyword_as_str_with" class="fn">read_keyword_as_str_with</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;(<a class="enum" href="https://doc.rust-lang.org/1.89.0/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.str.html">str</a>&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>)&gt; { ... }
</details>}</code></pre><h2 id="required-associated-types" class="section-header">Required Associated Types<a href="#required-associated-types" class="anchor">§</a></h2><div class="methods"><section id="associatedtype.State" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#78">Source</a><h4 class="code-header">type <a href="#associatedtype.State" class="associatedtype">State</a>: <a class="trait" href="state/trait.State.html" title="trait swc_ecma_lexer::common::lexer::state::State">State</a></h4></section><section id="associatedtype.Token" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#79">Source</a><h4 class="code-header">type <a href="#associatedtype.Token" class="associatedtype">Token</a>: <a class="trait" href="token/trait.TokenFactory.html" title="trait swc_ecma_lexer::common::lexer::token::TokenFactory">TokenFactory</a>&lt;'a, TokenAndSpan, Self, Lexer = Self&gt;</h4></section><section id="associatedtype.CommentsBuffer" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#80">Source</a><h4 class="code-header">type <a href="#associatedtype.CommentsBuffer" class="associatedtype">CommentsBuffer</a>: <a class="trait" href="comments_buffer/trait.CommentsBufferTrait.html" title="trait swc_ecma_lexer::common::lexer::comments_buffer::CommentsBufferTrait">CommentsBufferTrait</a></h4></section></div><h2 id="required-methods" class="section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><section id="tymethod.input" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#82">Source</a><h4 class="code-header">fn <a href="#tymethod.input" class="fn">input</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../struct.StringInput.html" title="struct swc_ecma_lexer::StringInput">StringInput</a>&lt;'a&gt;</h4></section><section id="tymethod.input_mut" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#83">Source</a><h4 class="code-header">fn <a href="#tymethod.input_mut" class="fn">input_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../../struct.StringInput.html" title="struct swc_ecma_lexer::StringInput">StringInput</a>&lt;'a&gt;</h4></section><section id="tymethod.state" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#84">Source</a><h4 class="code-header">fn <a href="#tymethod.state" class="fn">state</a>(&amp;self) -&gt; &amp;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.State" title="type swc_ecma_lexer::common::lexer::Lexer::State">State</a></h4></section><section id="tymethod.state_mut" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#85">Source</a><h4 class="code-header">fn <a href="#tymethod.state_mut" class="fn">state_mut</a>(&amp;mut self) -&gt; &amp;mut Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.State" title="type swc_ecma_lexer::common::lexer::Lexer::State">State</a></h4></section><section id="tymethod.comments" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#86">Source</a><h4 class="code-header">fn <a href="#tymethod.comments" class="fn">comments</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'a dyn <a class="trait" href="../../../swc_common/comments/trait.Comments.html" title="trait swc_common::comments::Comments">Comments</a>&gt;</h4></section><section id="tymethod.comments_buffer" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#87">Source</a><h4 class="code-header">fn <a href="#tymethod.comments_buffer" class="fn">comments_buffer</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.CommentsBuffer" title="type swc_ecma_lexer::common::lexer::Lexer::CommentsBuffer">CommentsBuffer</a>&gt;</h4></section><section id="tymethod.comments_buffer_mut" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#88">Source</a><h4 class="code-header">fn <a href="#tymethod.comments_buffer_mut" class="fn">comments_buffer_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.CommentsBuffer" title="type swc_ecma_lexer::common::lexer::Lexer::CommentsBuffer">CommentsBuffer</a>&gt;</h4></section><details class="toggle method-toggle" open><summary><section id="tymethod.input_slice" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#92">Source</a><h4 class="code-header">unsafe fn <a href="#tymethod.input_slice" class="fn">input_slice</a>(&amp;mut self, start: <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a>, end: <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a>) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.str.html">str</a></h4></section></summary><div class="docblock"><h5 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h5>
<p>We know that the start and the end are valid</p>
</div></details><section id="tymethod.input_uncons_while" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#93">Source</a><h4 class="code-header">fn <a href="#tymethod.input_uncons_while" class="fn">input_uncons_while</a>(&amp;mut self, f: impl <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.str.html">str</a></h4></section><section id="tymethod.atom" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#94">Source</a><h4 class="code-header">fn <a href="#tymethod.atom" class="fn">atom</a>&lt;'b&gt;(&amp;self, s: impl <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.89.0/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'b, <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.str.html">str</a>&gt;&gt;) -&gt; <a class="struct" href="../../../swc_atoms/struct.Atom.html" title="struct swc_atoms::Atom">Atom</a></h4></section><section id="tymethod.push_error" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#95">Source</a><h4 class="code-header">fn <a href="#tymethod.push_error" class="fn">push_error</a>(&amp;mut self, error: <a class="struct" href="../../error/struct.Error.html" title="struct swc_ecma_lexer::error::Error">Error</a>)</h4></section></div><h2 id="provided-methods" class="section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><section id="method.had_line_break_before_last" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#99-101">Source</a><h4 class="code-header">fn <a href="#method.had_line_break_before_last" class="fn">had_line_break_before_last</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a></h4></section><section id="method.span" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#104-114">Source</a><h4 class="code-header">fn <a href="#method.span" class="fn">span</a>(&amp;self, start: <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a>) -&gt; <a class="struct" href="../../../swc_common/syntax_pos/struct.Span.html" title="struct swc_common::syntax_pos::Span">Span</a></h4></section><section id="method.bump" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#117-122">Source</a><h4 class="code-header">fn <a href="#method.bump" class="fn">bump</a>(&amp;mut self)</h4></section><section id="method.is" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#125-127">Source</a><h4 class="code-header">fn <a href="#method.is" class="fn">is</a>(&amp;self, c: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u8.html">u8</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a></h4></section><section id="method.is_str" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#130-132">Source</a><h4 class="code-header">fn <a href="#method.is_str" class="fn">is_str</a>(&amp;self, s: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a></h4></section><section id="method.eat" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#135-137">Source</a><h4 class="code-header">fn <a href="#method.eat" class="fn">eat</a>(&amp;mut self, c: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u8.html">u8</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a></h4></section><section id="method.cur" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#140-142">Source</a><h4 class="code-header">fn <a href="#method.cur" class="fn">cur</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.char.html">char</a>&gt;</h4></section><section id="method.peek" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#145-147">Source</a><h4 class="code-header">fn <a href="#method.peek" class="fn">peek</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.char.html">char</a>&gt;</h4></section><section id="method.peek_ahead" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#150-152">Source</a><h4 class="code-header">fn <a href="#method.peek_ahead" class="fn">peek_ahead</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.char.html">char</a>&gt;</h4></section><section id="method.cur_pos" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#155-157">Source</a><h4 class="code-header">fn <a href="#method.cur_pos" class="fn">cur_pos</a>(&amp;self) -&gt; <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a></h4></section><section id="method.last_pos" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#160-162">Source</a><h4 class="code-header">fn <a href="#method.last_pos" class="fn">last_pos</a>(&amp;self) -&gt; <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a></h4></section><details class="toggle method-toggle" open><summary><section id="method.error" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#167-170">Source</a><h4 class="code-header">fn <a href="#method.error" class="fn">error</a>&lt;T&gt;(&amp;self, start: <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a>, kind: <a class="enum" href="../../error/enum.SyntaxError.html" title="enum swc_ecma_lexer::error::SyntaxError">SyntaxError</a>) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Shorthand for <code>let span = self.span(start); self.error_span(span)</code></p>
</div></details><section id="method.error_span" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#174-176">Source</a><h4 class="code-header">fn <a href="#method.error_span" class="fn">error_span</a>&lt;T&gt;(&amp;self, span: <a class="struct" href="../../../swc_common/syntax_pos/struct.Span.html" title="struct swc_common::syntax_pos::Span">Span</a>, kind: <a class="enum" href="../../error/enum.SyntaxError.html" title="enum swc_ecma_lexer::error::SyntaxError">SyntaxError</a>) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;T&gt;</h4></section><section id="method.emit_error" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#180-183">Source</a><h4 class="code-header">fn <a href="#method.emit_error" class="fn">emit_error</a>(&amp;mut self, start: <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a>, kind: <a class="enum" href="../../error/enum.SyntaxError.html" title="enum swc_ecma_lexer::error::SyntaxError">SyntaxError</a>)</h4></section><section id="method.emit_error_span" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#187-194">Source</a><h4 class="code-header">fn <a href="#method.emit_error_span" class="fn">emit_error_span</a>(&amp;mut self, span: <a class="struct" href="../../../swc_common/syntax_pos/struct.Span.html" title="struct swc_common::syntax_pos::Span">Span</a>, kind: <a class="enum" href="../../error/enum.SyntaxError.html" title="enum swc_ecma_lexer::error::SyntaxError">SyntaxError</a>)</h4></section><section id="method.emit_strict_mode_error" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#198-206">Source</a><h4 class="code-header">fn <a href="#method.emit_strict_mode_error" class="fn">emit_strict_mode_error</a>(&amp;mut self, start: <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a>, kind: <a class="enum" href="../../error/enum.SyntaxError.html" title="enum swc_ecma_lexer::error::SyntaxError">SyntaxError</a>)</h4></section><section id="method.emit_module_mode_error" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#210-214">Source</a><h4 class="code-header">fn <a href="#method.emit_module_mode_error" class="fn">emit_module_mode_error</a>(&amp;mut self, start: <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a>, kind: <a class="enum" href="../../error/enum.SyntaxError.html" title="enum swc_ecma_lexer::error::SyntaxError">SyntaxError</a>)</h4></section><section id="method.skip_line_comment" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#217-323">Source</a><h4 class="code-header">fn <a href="#method.skip_line_comment" class="fn">skip_line_comment</a>(&amp;mut self, start_skip: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.usize.html">usize</a>)</h4></section><details class="toggle method-toggle" open><summary><section id="method.skip_block_comment" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#326-454">Source</a><h4 class="code-header">fn <a href="#method.skip_block_comment" class="fn">skip_block_comment</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Expects current char to be ‘/’ and next char to be ‘*’.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.skip_space" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#460-493">Source</a><h4 class="code-header">fn <a href="#method.skip_space" class="fn">skip_space</a>&lt;const LEX_COMMENTS: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>&gt;(&amp;mut self)</h4></section></summary><div class="docblock"><p>Skip comments or whitespaces.</p>
<p>See https://tc39.github.io/ecma262/#sec-white-space</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ensure_not_ident" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#496-504">Source</a><h4 class="code-header">fn <a href="#method.ensure_not_ident" class="fn">ensure_not_ident</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Ensure that ident cannot directly follow numbers.</p>
</div></details><section id="method.make_legacy_octal" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#506-513">Source</a><h4 class="code-header">fn <a href="#method.make_legacy_octal" class="fn">make_legacy_octal</a>(&amp;mut self, start: <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a>, val: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.f64.html">f64</a>) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.f64.html">f64</a>&gt;</h4></section><details class="toggle method-toggle" open><summary><section id="method.read_digits" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#516-601">Source</a><h4 class="code-header">fn <a href="#method.read_digits" class="fn">read_digits</a>&lt;F, Ret, const RADIX: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u8.html">u8</a>&gt;(
    &amp;mut self,
    op: F,
    allow_num_separator: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>,
    has_underscore: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>,
) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Ret&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Ret, <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u8.html">u8</a>, <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u32.html">u32</a>) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;(Ret, <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>)&gt;,
    Ret: <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> + <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a>,</div></h4></section></summary><div class="docblock"><p><code>op</code>- |total, radix, value| -&gt; (total * radix + value, continue)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_number_no_dot_as_str" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#607-642">Source</a><h4 class="code-header">fn <a href="#method.read_number_no_dot_as_str" class="fn">read_number_no_dot_as_str</a>&lt;const RADIX: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u8.html">u8</a>&gt;(
    &amp;mut self,
) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;<a class="struct" href="number/struct.LazyInteger.html" title="struct swc_ecma_lexer::common::lexer::number::LazyInteger">LazyInteger</a>&gt;</h4></section></summary><div class="docblock"><p>This can read long integers like
“13612536612375123612312312312312312312312”.</p>
<ul>
<li>Returned <code>bool</code> is <code>true</code> is there was <code>8</code> or <code>9</code>.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_number" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#645-799">Source</a><h4 class="code-header">fn <a href="#method.read_number" class="fn">read_number</a>&lt;const START_WITH_DOT: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>, const START_WITH_ZERO: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>&gt;(
    &amp;mut self,
) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;<a class="enum" href="../../../either/enum.Either.html" title="enum either::Either">Either</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.f64.html">f64</a>, <a class="struct" href="../../../swc_atoms/struct.Atom.html" title="struct swc_atoms::Atom">Atom</a>), (<a class="struct" href="https://doc.rust-lang.org/1.89.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="struct" href="../../../num_bigint/bigint/struct.BigInt.html" title="struct num_bigint::bigint::BigInt">BigIntValue</a>&gt;, <a class="struct" href="../../../swc_atoms/struct.Atom.html" title="struct swc_atoms::Atom">Atom</a>)&gt;&gt;</h4></section></summary><div class="docblock"><p>Reads an integer, octal integer, or floating-point number</p>
</div></details><section id="method.read_int_u32" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#801-828">Source</a><h4 class="code-header">fn <a href="#method.read_int_u32" class="fn">read_int_u32</a>&lt;const RADIX: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u8.html">u8</a>&gt;(&amp;mut self, len: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u8.html">u8</a>) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u32.html">u32</a>&gt;&gt;</h4></section><details class="toggle method-toggle" open><summary><section id="method.read_radix_number" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#831-877">Source</a><h4 class="code-header">fn <a href="#method.read_radix_number" class="fn">read_radix_number</a>&lt;const RADIX: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u8.html">u8</a>&gt;(
    &amp;mut self,
) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;<a class="enum" href="../../../either/enum.Either.html" title="enum either::Either">Either</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.f64.html">f64</a>, <a class="struct" href="../../../swc_atoms/struct.Atom.html" title="struct swc_atoms::Atom">Atom</a>), (<a class="struct" href="https://doc.rust-lang.org/1.89.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="struct" href="../../../num_bigint/bigint/struct.BigInt.html" title="struct num_bigint::bigint::BigInt">BigIntValue</a>&gt;, <a class="struct" href="../../../swc_atoms/struct.Atom.html" title="struct swc_atoms::Atom">Atom</a>)&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns <code>Left(value)</code> or <code>Right(BigInt)</code></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.consume_pending_comments" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#884-913">Source</a><h4 class="code-header">fn <a href="#method.consume_pending_comments" class="fn">consume_pending_comments</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Consume pending comments.</p>
<p>This is called when the input is exhausted.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_jsx_word" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#921-936">Source</a><h4 class="code-header">fn <a href="#method.read_jsx_word" class="fn">read_jsx_word</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt;</h4></section></summary><div class="docblock"><p>Read a JSX identifier (valid tag or attribute name).</p>
<p>Optimized version since JSX identifiers can“t contain
escape characters and so can be read as single slice.
Also assumes that first character was already checked
by isIdentifierStart in readToken.</p>
</div></details><section id="method.read_jsx_entity" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#938-1002">Source</a><h4 class="code-header">fn <a href="#method.read_jsx_entity" class="fn">read_jsx_entity</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.char.html">char</a>, <a class="struct" href="https://doc.rust-lang.org/1.89.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>)&gt;</h4></section><section id="method.read_jsx_new_line" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#1004-1016">Source</a><h4 class="code-header">fn <a href="#method.read_jsx_new_line" class="fn">read_jsx_new_line</a>(
    &amp;mut self,
    normalize_crlf: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>,
) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;<a class="enum" href="../../../either/enum.Either.html" title="enum either::Either">Either</a>&lt;&amp;'static <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.str.html">str</a>, <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.char.html">char</a>&gt;&gt;</h4></section><section id="method.read_jsx_str" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#1018-1120">Source</a><h4 class="code-header">fn <a href="#method.read_jsx_str" class="fn">read_jsx_str</a>(&amp;mut self, quote: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.char.html">char</a>) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt;</h4></section><section id="method.read_unicode_escape" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#1122-1218">Source</a><h4 class="code-header">fn <a href="#method.read_unicode_escape" class="fn">read_unicode_escape</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.89.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="char/struct.Char.html" title="struct swc_ecma_lexer::common::lexer::char::Char">Char</a>&gt;&gt;</h4></section><section id="method.read_shebang" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#1221-1229">Source</a><h4 class="code-header">fn <a href="#method.read_shebang" class="fn">read_shebang</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../../swc_atoms/struct.Atom.html" title="struct swc_atoms::Atom">Atom</a>&gt;&gt;</h4></section><section id="method.read_tmpl_token" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#1231-1363">Source</a><h4 class="code-header">fn <a href="#method.read_tmpl_token" class="fn">read_tmpl_token</a>(&amp;mut self, start_of_tpl: <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a>) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt;</h4></section><details class="toggle method-toggle" open><summary><section id="method.read_escaped_char" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#1368-1484">Source</a><h4 class="code-header">fn <a href="#method.read_escaped_char" class="fn">read_escaped_char</a>(
    &amp;mut self,
    in_template: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>,
) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.89.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="char/struct.Char.html" title="struct swc_ecma_lexer::common::lexer::char::Char">Char</a>&gt;&gt;&gt;</h4></section></summary><div class="docblock"><p>Read an escaped character for string literal.</p>
<p>In template literal, we should preserve raw string.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_regexp" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#1487-1567">Source</a><h4 class="code-header">fn <a href="#method.read_regexp" class="fn">read_regexp</a>(&amp;mut self, start: <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a>) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt;</h4></section></summary><div class="docblock"><p>Expects current char to be ‘/’</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_word_as_str_with" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#1570-1620">Source</a><h4 class="code-header">fn <a href="#method.read_word_as_str_with" class="fn">read_word_as_str_with</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;(<a class="enum" href="https://doc.rust-lang.org/1.89.0/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.str.html">str</a>&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>)&gt;</h4></section></summary><div class="docblock"><p>This method is optimized for texts without escape sequences.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_word_as_str_with_slow_path" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#1624-1721">Source</a><h4 class="code-header">fn <a href="#method.read_word_as_str_with_slow_path" class="fn">read_word_as_str_with_slow_path</a>(
    &amp;mut self,
    slice_start: <a class="struct" href="../../../swc_common/syntax_pos/struct.BytePos.html" title="struct swc_common::syntax_pos::BytePos">BytePos</a>,
) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;(<a class="enum" href="https://doc.rust-lang.org/1.89.0/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.str.html">str</a>&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>)&gt;</h4></section></summary><div class="docblock"><p>Slow path for identifier parsing that handles Unicode and escapes</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_token_number_sign" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#1724-1736">Source</a><h4 class="code-header">fn <a href="#method.read_token_number_sign" class="fn">read_token_number_sign</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt;</h4></section></summary><div class="docblock"><p><code>#</code></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_token_dot" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#1742-1769">Source</a><h4 class="code-header">fn <a href="#method.read_token_dot" class="fn">read_token_dot</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt;</h4></section></summary><div class="docblock"><p>Read a token given <code>.</code>.</p>
<p>This is extracted as a method to reduce size of <code>read_token</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_token_question_mark" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#1775-1787">Source</a><h4 class="code-header">fn <a href="#method.read_token_question_mark" class="fn">read_token_question_mark</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt;</h4></section></summary><div class="docblock"><p>Read a token given <code>?</code>.</p>
<p>This is extracted as a method to reduce size of <code>read_token</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_token_colon" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#1793-1797">Source</a><h4 class="code-header">fn <a href="#method.read_token_colon" class="fn">read_token_colon</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt;</h4></section></summary><div class="docblock"><p>Read a token given <code>:</code>.</p>
<p>This is extracted as a method to reduce size of <code>read_token</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_token_zero" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#1803-1823">Source</a><h4 class="code-header">fn <a href="#method.read_token_zero" class="fn">read_token_zero</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt;</h4></section></summary><div class="docblock"><p>Read a token given <code>0</code>.</p>
<p>This is extracted as a method to reduce size of <code>read_token</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_token_logical" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#1829-1895">Source</a><h4 class="code-header">fn <a href="#method.read_token_logical" class="fn">read_token_logical</a>&lt;const C: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.u8.html">u8</a>&gt;(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt;</h4></section></summary><div class="docblock"><p>Read a token given <code>|</code> or <code>&amp;</code>.</p>
<p>This is extracted as a method to reduce size of <code>read_token</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_token_mul_mod" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#1901-1927">Source</a><h4 class="code-header">fn <a href="#method.read_token_mul_mod" class="fn">read_token_mul_mod</a>(&amp;mut self, is_mul: <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt;</h4></section></summary><div class="docblock"><p>Read a token given <code>*</code> or <code>%</code>.</p>
<p>This is extracted as a method to reduce size of <code>read_token</code>.</p>
</div></details><section id="method.read_slash" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#1930-1938">Source</a><h4 class="code-header">fn <a href="#method.read_slash" class="fn">read_slash</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt;</h4></section><details class="toggle method-toggle" open><summary><section id="method.read_ident_unknown" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#1942-1954">Source</a><h4 class="code-header">fn <a href="#method.read_ident_unknown" class="fn">read_ident_unknown</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt;</h4></section></summary><div class="docblock"><p>This can be used if there’s no keyword starting with the first
character.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_str_lit" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#1958-2073">Source</a><h4 class="code-header">fn <a href="#method.read_str_lit" class="fn">read_str_lit</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt;</h4></section></summary><div class="docblock"><p>See https://tc39.github.io/ecma262/#sec-literals-string-literals</p>
</div></details><section id="method.read_keyword_with" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#2075-2100">Source</a><h4 class="code-header">fn <a href="#method.read_keyword_with" class="fn">read_keyword_with</a>(
    &amp;mut self,
    convert: &amp;dyn <a class="trait" href="https://doc.rust-lang.org/1.89.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(&amp;<a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.89.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt;,
) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;Self::<a class="associatedtype" href="trait.Lexer.html#associatedtype.Token" title="type swc_ecma_lexer::common::lexer::Lexer::Token">Token</a>&gt;</h4></section><details class="toggle method-toggle" open><summary><section id="method.read_keyword_as_str_with" class="method"><a class="src rightside" href="../../../src/swc_ecma_lexer/common/lexer/mod.rs.html#2105-2146">Source</a><h4 class="code-header">fn <a href="#method.read_keyword_as_str_with" class="fn">read_keyword_as_str_with</a>(&amp;mut self) -&gt; <a class="type" href="type.LexResult.html" title="type swc_ecma_lexer::common::lexer::LexResult">LexResult</a>&lt;(<a class="enum" href="https://doc.rust-lang.org/1.89.0/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.str.html">str</a>&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.89.0/std/primitive.bool.html">bool</a>)&gt;</h4></section></summary><div class="docblock"><p>This is a performant version of <a href="trait.Lexer.html#method.read_word_as_str_with" title="method swc_ecma_lexer::common::lexer::Lexer::read_word_as_str_with">Lexer::read_word_as_str_with</a> for
reading keywords. We should make sure the first byte is a valid
ASCII.</p>
</div></details></div><h2 id="dyn-compatibility" class="section-header">Dyn Compatibility<a href="#dyn-compatibility" class="anchor">§</a></h2><div class="dyn-compatibility-info"><p>This trait is <b>not</b> <a href="https://doc.rust-lang.org/1.89.0/reference/items/traits.html#dyn-compatibility">dyn compatible</a>.</p><p><i>In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.</i></p></div><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"><details class="toggle implementors-toggle"><summary><section id="impl-Lexer%3C'a,+TokenAndSpan%3E-for-Lexer%3C'a%3E" class="impl"><a class="src rightside" href="../../../src/swc_ecma_lexer/lexer/mod.rs.html#57-116">Source</a><a href="#impl-Lexer%3C'a,+TokenAndSpan%3E-for-Lexer%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="trait.Lexer.html" title="trait swc_ecma_lexer::common::lexer::Lexer">Lexer</a>&lt;'a, <a class="struct" href="../../token/struct.TokenAndSpan.html" title="struct swc_ecma_lexer::token::TokenAndSpan">TokenAndSpan</a>&gt; for <a class="struct" href="../../lexer/struct.Lexer.html" title="struct swc_ecma_lexer::lexer::Lexer">Lexer</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><section id="associatedtype.CommentsBuffer-1" class="associatedtype trait-impl"><a class="src rightside" href="../../../src/swc_ecma_lexer/lexer/mod.rs.html#58">Source</a><a href="#associatedtype.CommentsBuffer-1" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.CommentsBuffer" class="associatedtype">CommentsBuffer</a> = CommentsBuffer</h4></section><section id="associatedtype.State-1" class="associatedtype trait-impl"><a class="src rightside" href="../../../src/swc_ecma_lexer/lexer/mod.rs.html#59">Source</a><a href="#associatedtype.State-1" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.State" class="associatedtype">State</a> = State</h4></section><section id="associatedtype.Token-1" class="associatedtype trait-impl"><a class="src rightside" href="../../../src/swc_ecma_lexer/lexer/mod.rs.html#60">Source</a><a href="#associatedtype.Token-1" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Token" class="associatedtype">Token</a> = <a class="enum" href="../../token/enum.Token.html" title="enum swc_ecma_lexer::token::Token">Token</a></h4></section></div></details></div><script src="../../../trait.impl/swc_ecma_lexer/common/lexer/trait.Lexer.js" async></script></section></div></main></body></html>