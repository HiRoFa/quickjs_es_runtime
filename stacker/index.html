<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A library to help grow the stack when it runs out of space."><title>stacker - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-84e720fa.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="stacker" data-themes="" data-resource-suffix="" data-rustdoc-version="1.89.0 (29483883e 2025-08-04)" data-channel="1.89.0" data-search-js="search-92309212.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-fd3af306.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../stacker/index.html">stacker</a><span class="version">0.1.21</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#examples" title="Examples">Examples</a></li></ul><h3><a href="#functions">Crate Items</a></h3><ul class="block"><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>stacker</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/stacker/lib.rs.html#1-181">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A library to help grow the stack when it runs out of space.</p>
<p>This is an implementation of manually instrumented segmented stacks where points in a program’s
control flow are annotated with “maybe grow the stack here”. Each point of annotation indicates
how far away from the end of the stack it’s allowed to be, plus the amount of stack to allocate
if it does reach the end.</p>
<p>Once a program has reached the end of its stack, a temporary stack on the heap is allocated and
is switched to for the duration of a closure.</p>
<p>For a set of lower-level primitives, consider the <code>psm</code> crate.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Grow the stack if we are within the "red zone" of 32K, and if we allocate
// a new stack allocate 1MB of stack space.
//
// If we're already in bounds, just run the provided closure on current stack.
</span>stacker::maybe_grow(<span class="number">32 </span>* <span class="number">1024</span>, <span class="number">1024 </span>* <span class="number">1024</span>, || {
    <span class="comment">// guaranteed to have at least 32K of stack
</span>});</code></pre></div>
</div></details><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.grow.html" title="fn stacker::grow">grow</a></dt><dd>Always creates a new stack for the passed closure to run on.
The closure will still be on the same thread as the caller of <code>grow</code>.
This will allocate a new stack with at least <code>stack_size</code> bytes.</dd><dt><a class="fn" href="fn.maybe_grow.html" title="fn stacker::maybe_grow">maybe_<wbr>grow</a></dt><dd>Grows the call stack if necessary.</dd><dt><a class="fn" href="fn.remaining_stack.html" title="fn stacker::remaining_stack">remaining_<wbr>stack</a></dt><dd>Queries the amount of remaining stack as interpreted by this library.</dd></dl></section></div></main></body></html>