searchState.loadedDescShard("swc_ecma_utils", 0, "Finds all <strong>binding</strong> idents of variables.\nFinds all <strong>binding</strong> idents of variables.\nExtension methods for Expr.\nExtension methods for Expr.\nReplacer for Id =&gt; ]Id]\nFinds usage of <code>ident</code>\nMay have some side effects.\nA newtype that will ignore Span while doing <code>eq</code> or <code>hash</code>.\nDoes not have any side effect.\nReplace <code>foo</code> with <code>bar</code> or <code>bar.baz</code>\nVariable remapper\nPrepends statements after directive statements.\nType of value.\nNot determined at compile time.`\nNot determined at compile time.`\nRuntime value.\nUsed to determine super_class_ident\nUsed to determine super_class_ident\nReturns <code>(ident, aliased)</code>\nCreates an ExprOrSpread using the given Expr.\nCreates an ExprOrSpread using the given Expr.\nGet bool value of <code>self</code> if it does not have any side …\nEmulates javascript Number() cast function.\nReturns Known only if it’s pure.\nThis method emulates the <code>Boolean()</code> JavaScript cast …\nCollects binding identifiers.\nCollects binding identifiers, but only if it has a context …\nThis does not recurse into a function if <code>this</code> is changed …\n<code>super_call_span</code> should be the span of the class definition …\nAdd side effects of <code>expr</code> to <code>to</code>. This function preserves …\nExtracts hoisted variables\nExtracts hoisted variables\nFinds all <strong>binding</strong> idents of <code>node</code>.\nFinds all <strong>binding</strong> idents of <code>node</code>. <strong>Any nested identifiers in</strong>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nApply the supplied predicate against all possible result …\nTrue if we are in the strict mode. This will be set to <code>true</code>…\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\ncreate a ArrowExpr which return self\ncreate a ArrowExpr which return self\ncreate a Function which return self\ncreate a Function which return self\nCreates a statement whcih return <code>self</code>.\nCreates a statement whcih return <code>self</code>.\nCreates an expression statement with <code>self</code>.\nCreates an expression statement with <code>self</code>.\ncreate a var declartor using self as init\ncreate a var declartor using self as init\nReturns <code>true</code> if <code>id</code> references a global object.\nReturns true if this is an immutable value.\nReturns true if the value is known.\nIf the stmt is maybe a directive like <code>&quot;use strict&quot;;</code>\nChecks if <code>self</code> is <code>NaN</code>.\nReturns <code>true</code> if <code>id</code> references a global object.\nReturns true if it’s pure.\nCheck if <code>e</code> is <code>...arguments</code>\nReturns true if the value is not known.\nTrue for argument of <code>typeof</code>.\nCreates a assign expr <code>$lhs $op $self</code>\nCreates a assign expr <code>$lhs $op $self</code>\nCreates a binary expr <code>$self $op $rhs</code>\nCreates a binary expr <code>$self $op $rhs</code>\nCreates a binary expr <code>$self === </code>\nCreates a binary expr <code>$self === </code>\nCreates a member expression.\nModule for parallel processing\ninject <code>branch</code> after directives\ninject <code>stmts</code> after directives\nmake a new expression which evaluates <code>val</code> preserving side …\nShortcut for …\nSimilar to <code>prop_name_to_expr</code>, but used for value position.\nref used in JSX\nAs we have multiple identifier types, the expected usage is\nRemaining depth of the current expression. If this is 0, …\nReplace all <code>from</code> in <code>expr</code> with <code>to</code>.\nwhen <code>foo()</code> is replaced with <code>bar.baz()</code>, should <code>bar.baz</code> be …\nstmts contain top level return/break/continue/throw\nCast to javascript’s int32\nThis SyntaxContext should be applied only to unresolved …\nDon’t recurse into constructor\nDon’t recurse into constructor\nNo-op (we don’t care about expressions)\nNo-op (we don’t care about expressions)\nDon’t recurse into fn\nDon’t recurse into fn\nDon’t recurse into fn\nDon’t recurse into fn\nDon’t recurse into fn\nDon’t recurse into fn\nreplace bar in binding pattern input:\nNo-op (we don’t care about expressions)\nDon’t recurse into fn\nDon’t use it against function, it will stop if come …\nDisable hoisting of <code>arguments</code>\nDisable hoisting of nodes realted to <code>super</code>\nDisable hoisting of <code>this</code>\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDon’t recurse into constructor\nDon’t recurse into fn\nDon’t recurse into getter/setter/method except computed …\nhttps://tc39.es/ecma262/#sec-numeric-types-number-tostring\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis is considered as a private type and it’s NOT A …\nInvoked after visiting all ModuleItems, possibly in …\nInvoked after visiting all Stmts, possibly in parallel.\nUsed to create visitor.\nInvoke <code>op</code> in parallel, if <code>swc_ecma_utils</code> is compiled with …\nInvoke <code>op</code> in parallel, if <code>swc_ecma_utils</code> is compiled with …\nIf you don’t have a special reason, use …\nThis can be called in anytime.\nCalls <code>callback</code> with a larger stack size.\nCalls <code>callback</code> with a larger stack size.\nU+000D CARRIAGE RETURN, abbreviated in the spec as <code>&lt;CR&gt;</code>.\nU+000C FORM FEED, abbreviated <code>&lt;FF&gt;</code>.\nU+000A LINE FEED, abbreviated in the spec as <code>&lt;LF&gt;</code>.\nU+2028 LINE SEPARATOR, abbreviated <code>&lt;LS&gt;</code>.\nU+00A0 NON-BREAKING SPACE, abbreviated <code>&lt;NBSP&gt;</code>.\nU+2029 PARAGRAPH SEPARATOR, abbreviated <code>&lt;PS&gt;</code>.\nU+0020 SPACE, abbreviated <code>&lt;SP&gt;</code>.\nU+0009 CHARACTER TABULATION, abbreviated <code>&lt;TAB&gt;</code>.\nU+000B VERTICAL TAB, abbreviated <code>&lt;VT&gt;</code>.\nU+200D ZERO WIDTH JOINER, abbreviated as <code>&lt;ZWJ&gt;</code>. Specially …\nU+FEFF ZERO WIDTH NO-BREAK SPACE, abbreviated <code>&lt;ZWNBSP&gt;</code>. …\nU+200C ZERO WIDTH NON-JOINER, abbreviated in the spec as …\nThis collects variables bindings while ignoring if it’s …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")