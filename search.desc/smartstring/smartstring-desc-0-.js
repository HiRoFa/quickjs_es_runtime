searchState.loadedDescShard("smartstring", 0, "Smart String\nA compact string representation equal to <code>String</code> in size …\nA constant to decide whether to turn a wrapped string back …\nA draining iterator for a <code>SmartString</code>.\nThe inline string type for this layout.\nA representation similar to <code>Compact</code> but which doesn’t …\nThe maximum capacity of an inline string, in bytes.\nA smart string.\nMarker trait for <code>SmartString</code> representations.\nConvenient type aliases.\nGet a reference to the string as a mutable string slice.\nGet a reference to the string as a string slice.\nReturn the currently allocated capacity of the string.\nClear the string.\nClone a <code>SmartString</code>.\nConstruct a draining iterator over a given range.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInsert a <code>char</code> into the string at the given index.\nInsert a string slice into the string at the given index.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTest whether the string is empty.\nTest whether the string is currently inlined.\nReturn the length in bytes of the string.\nConstruct an empty string.\nConstruct an empty string.\nConstruct an empty string.\nPop a <code>char</code> off the end of the string.\nPush a character to the end of the string.\nCopy a string slice onto the end of the string.\nRemove a <code>char</code> from the string at the given index.\nReplaces a range with the contents of a string slice.\nFilter out <code>char</code>s not matching a predicate.\nShrink the capacity of the string to fit its contents …\nSplit the string into two at the given index.\nTruncate the string to <code>new_len</code> bytes.\nA convenience alias for a <code>Compact</code> layout <code>SmartString</code>.\nA convenience alias for a <code>LazyCompact</code> layout <code>SmartString</code>.")