searchState.loadedDescShard("swc_ecma_parser", 0, "EcmaScript/TypeScript parser for the rust programming …\nContains the error value\nStandard\n<code>true</code> while backtracking\nIf true, await expression is parsed, and “await” is …\nIf true, <code>:</code> should not be treated as a type annotation.\nTypescript extension.\nIf true, yield expression is parsed, and “yield” is …\nIf true, await is treated as a keyword.\nThis indicates current scope or the scope out of arrow …\nIs in module code?\nContains the success value\nEcmaScript parser.\nTypescript extension.\nImplementation of Input.\nThis variant requires the cargo feature <code>typescript</code> to be …\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nSafety\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nReturns None if it’s end of input <strong>or</strong> current character …\nTODO(kdy1): Remove this?\nEnable decorators.\nbabel: <code>decorators.decoratorsBeforeExport</code>\nThe intersection of a source flags value with the …\nbabel: <code>disallowAmbiguousJSXLike</code> Even when JSX parsing is …\n<code>.d.ts</code>\nImplementors can override the method to make it faster.\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nSupport function bind expression.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nStage 4 Always true in swc\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nImplementors can override the method to make it faster.\nWhether all bits in this flags value are unset.\nImplementors can override the method to make it faster.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nShould we parse jsx?\nECMAScript lexer.\n<code>start</code> and <code>end</code> can be arbitrary value, but start should be …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nNote: This is recommended way to parse a file.\nNote: This is recommended way to parse a file.\nNote: This is recommended way to parse a file.\nNote: This is recommended way to parse a file.\nNote: This is recommended way to parse a file.\nReturns Module if it’s a module and returns Script if it…\nParse a statement but not a declaration.\nParse a statement and maybe a declaration.\nThe intersection of a source flags value with the …\nSafety\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nSafety\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nPorted from babel/babylon\nShould we parse typescript?\nTakes items from stream, testing each one with predicate. …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\n<code>()</code>\nNote: this struct is 8 bytes.\n‘eval’ and ‘arguments’ are invalid identifier in …\n“implements”, “interface”, “let”, “package”…\nUnexpected token\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSpan of the previous default case\nThis struct is responsible for managing current token and …\nClone should be cheap if you are parsing typescript …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPeeked token\nSpan of the previous token.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>+</code>\n‘=&gt;’\n‘@’\nSpec says this might be identifier.\n‘`’\n‘!’\n<code>&amp;</code>\n<code>|</code>\n<code>^</code>\n‘:’\n‘,’\n<code>/</code>\n‘${’\n‘.’\n‘…’\n<code>==</code>\n<code>===</code>\n<code>**</code>\n<code>&gt;</code>\n<code>&gt;=</code>\n‘#’\nKeywords\n‘{’\n<code>[</code>\n‘(’\n<code>&lt;&lt;</code>\n<code>&amp;&amp;</code>\n<code>||</code>\n<code>&lt;</code>\n<code>&lt;=</code>\n<code>--</code>\n<code>%</code>\n<code>*</code>\n<code>!=</code>\n<code>!==</code>\n<code>??</code>\nTODO: Make Num as enum and separate decimal, binary, ..etc\n<code>++</code>\n‘?’\n‘}’\n‘]’\n‘)’\n<code>&gt;&gt;</code>\nWe abuse <code>token.raw</code> for flags\nRegexp literal.\n‘;’\nString literal. Span of this token contains quote.\n<code>-</code>\n<code>~</code>\nIdentifier, “null”, “true”, “false”.\nSpec says this might be identifier.\n<code>&gt;&gt;&gt;</code>\nThis method is called only in the case of parsing failure.\nReturns true if <code>self</code> can follow keyword let.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHad a line break before this token?\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")