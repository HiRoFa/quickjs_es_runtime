searchState.loadedDescShard("swc_ecma_lexer", 0, "swc_ecma_lexer\nEcmaScript parser.\nImplementation of Input.\nTODO(kdy1): Remove this?\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nECMAScript lexer.\n<code>start</code> and <code>end</code> can be arbitrary value, but start should be …\nReturns Module if it’s a module and returns Script if it…\nPorted from babel/babylon\n<code>true</code> while backtracking\nIf true, await expression is parsed, and “await” is …\nIf true, <code>:</code> should not be treated as a type annotation.\nTypescript extension.\nIf true, yield expression is parsed, and “yield” is …\nIf true, await is treated as a keyword.\nThis indicates current scope or the scope out of arrow …\nIs in module code?\nTypescript extension.\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nClone should be cheap if you are parsing typescript …\nImplementors should use Rc&lt;RefCell&lt;Vec&gt;&gt;.\nAdd an error which is valid syntax in script mode.\nIf the program was parsed as a script, this contains the …\nContains the error value\nContains the success value\nConsume pending comments.\nEnsure that ident cannot directly follow numbers.\nShorthand for …\nSafety\n<code>op</code>- |total, radix, value| -&gt; (total * radix + value, …\nRead an escaped character for string literal.\nThis can be used if there’s no keyword starting with the …\nRead a JSX identifier (valid tag or attribute name).\nThis is a performant version of …\nReads an integer, octal integer, or floating-point number\nThis can read long integers like “…\nReturns <code>Left(value)</code> or <code>Right(BigInt)</code>\nExpects current char to be ‘/’\nSee …\nRead a token given <code>:</code>.\nRead a token given <code>.</code>.\nRead a token given <code>|</code> or <code>&amp;</code>.\nRead a token given <code>*</code> or <code>%</code>.\n<code>#</code>\nRead a token given <code>?</code>.\nRead a token given <code>0</code>.\nThis method is optimized for texts without escape …\nSlow path for identifier parsing that handles Unicode and …\nExpects current char to be ‘/’ and next char to be ‘*…\nSkip comments or whitespaces.\nImplemented for <code>char</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTest whether a given character is part of an identifier.\nTest whether a given character code starts an identifier.\nSee …\nSee https://tc39.github.io/ecma262/#sec-line-terminators\nSee https://tc39.github.io/ecma262/#sec-white-space\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nContains the error value\nContains the success value\nOriginal context is restored when returned guard is …\nMark as declare\nAssignmentExpression[+In, ?Yield, ?Await] ……\nspec: ‘PropertyName’\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nfind next token.\nReturns start of current token.\nThis returns true on eof.\nReturns last byte position of previous token.\n<code>parse_args</code> closure should not eat ‘(’ or ‘)’.\nParse function expression\nIf <code>required</code> is <code>true</code>, this never returns <code>None</code>.\nParse <code>Arguments[Yield, Await]</code>\n<code>parseMaybeAssign</code> (overridden)\nName from spec: ‘LogicalORExpression’\nParse binary operators with the operator precedence parsing\nParse call, dot, and <code>[]</code>-subscript expressions.\n<code>is_new_expr</code>: true iff we are parsing production ‘…\nParse <code>NewExpression</code>. This includes <code>MemberExpression</code>.\n“IsValidSimpleAssignmentTarget” from spec.\nbabel: <code>parseBindingIdentifier</code>\nIdentifier\nUse this when spec says “IdentifierName”. This allows …\nIdentifierReference\nLabelIdentifier\nJSXEmptyExpression is unique type since it doesn’t …\nParses JSX expression enclosed into curly brackets.\nFrom babel..\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStart position of an assignment expression.\nStart position of an AST node and the span of its trailing …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nParse a statement, declaration or module item.\nParse a statement and maybe a declaration.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>tsIsStartOfMappedType</code>\n<code>tsParseEntityName</code>\n<code>tsParseEnumDeclaration</code>\n<code>tsParseExpressionStatement</code>\n<code>tsParseHeritageClause</code>\n<code>tsParseImportEqualsDeclaration</code>\n<code>tsParseInterfaceDeclaration</code>\n<code>tsParseMappedType</code>\nParses a modifier matching one the given modifier names.\n<code>tsParseParenthesizedType</code>\n<code>tsParseThisTypeNode</code>\n<code>tsParseThisTypePredicate</code>\n<code>tsParseTupleType</code>\nBe sure to be in a type context before calling p.\n<code>tsParseTypeAliasDeclaration</code>\n<code>tsParseTypeArguments</code>\n<code>tsParseTypeAssertion</code>\n<code>tsParseTypeLiteral</code>\n<code>tsParseTypeOrTypePredicateAnnotation</code>\n<code>tsParseTypeParameter</code>\n<code>tsParseTypeReference</code>\n<code>tsTryParse</code>\n<code>tsTryParseDeclare</code>\n<code>tsTryParseExportDeclaration</code>\n<code>tsTryParseGenericAsyncArrowFunction</code>\n<code>tsTryParseIndexSignature</code>\n<code>tsTryParseTypeAnnotation</code>\n<code>tsTryParseTypeOrTypePredicateAnnotation</code>\n<code>tsTryParseTypeParameters</code>\nStandard\nThis variant requires the cargo feature <code>typescript</code> to be …\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nEnable decorators.\nbabel: <code>decorators.decoratorsBeforeExport</code>\nThe intersection of a source flags value with the …\nbabel: <code>disallowAmbiguousJSXLike</code> Even when JSX parsing is …\n<code>.d.ts</code>\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nSupport function bind expression.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nStage 4 Always true in swc\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nShould we parse jsx?\nShould we parse jsx?\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nShould we parse typescript?\nShould we parse typescript?\nThe bitwise or (<code>|</code>) of the bits in two flags values.\n<code>()</code>\nNote: this struct is 8 bytes.\n‘eval’ and ‘arguments’ are invalid identifier in …\n“implements”, “interface”, “let”, “package”…\nUnexpected token\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSpan of the previous default case\nThis struct is responsible for managing current token and …\nNote: Lexer need access to parser’s context to lex …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPeeked token\nSpan of the previous token.\nTake captured tokens\nThe algorithm used to determine whether a regexp can …\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nIs this <code>for</code> loop?\n<code>+</code>\n‘=&gt;’\n‘@’\nSpec says this might be identifier.\n‘`’\n‘!’\n<code>&amp;</code>\n<code>|</code>\n<code>^</code>\n‘:’\n‘,’\n<code>/</code>\n‘${’\n‘.’\n‘…’\n<code>==</code>\n<code>===</code>\n<code>**</code>\n<code>&gt;</code>\n<code>&gt;=</code>\n‘#’\nKeywords\n‘{’\n<code>[</code>\n‘(’\n<code>&lt;&lt;</code>\n<code>&amp;&amp;</code>\n<code>||</code>\n<code>&lt;</code>\n<code>&lt;=</code>\n<code>--</code>\n<code>%</code>\n<code>*</code>\n<code>!=</code>\n<code>!==</code>\n<code>??</code>\nTODO: Make Num as enum and separate decimal, binary, ..etc\n<code>++</code>\n‘?’\n‘}’\n‘]’\n‘)’\n<code>&gt;&gt;</code>\nWe abuse <code>token.raw</code> for flags\nRegexp literal.\n‘;’\nString literal. Span of this token contains quote.\n<code>-</code>\n<code>~</code>\nIdentifier, “null”, “true”, “false”.\nSpec says this might be identifier.\n<code>&gt;&gt;&gt;</code>\nThis method is called only in the case of parsing failure.\nReturns true if <code>self</code> can follow keyword let.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHad a line break before this token?\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")