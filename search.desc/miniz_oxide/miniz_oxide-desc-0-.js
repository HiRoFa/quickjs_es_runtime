searchState.loadedDescShard("miniz_oxide", 0, "A pure rust replacement for the miniz DEFLATE/zlib …\nNot implemented.\nBuffer-related error.\nError in inflation; see <code>inflate::stream::inflate()</code> for …\nHow compressed data is wrapped.\nContains the error value\nUnused\nAttempt to flush the remaining data and end the stream.\nSame as <code>Sync</code>, but resets the compression dictionary so …\nA list of miniz failed status codes.\nA list of flush types.\n<code>Result</code> alias for all miniz status codes both successful …\nA list of miniz successful status codes.\nUnused\nUnused\nDon’t force any flushing. Used when more input data is …\nContains the success value\nOperation succeeded.\nBad parameters.\nZlib partial flush. Currently treated as <code>Sync</code>.\nRaw DEFLATE.\nGeneral stream error.\nOperation succeeded and end of deflate stream was found.\nA structure containing the result of a call to the inflate …\nFinish compressing the currently buffered data, and output …\nUnused\nZlib wrapped but ignore and don’t compute the adler32 …\nWrapped using the zlib format.\nThe number of bytes consumed from the input slice.\nThe number of bytes written to the output slice.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThis module contains functionality for decompression.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an MZFlush value from an integer value.\nThe return status of the call.\nThe decompression went fine, but the adler32 checksum did …\nThe output buffer is an invalid size; consider the <code>flags</code> …\nFinished decompression without issues.\nFailed to decompress due to invalid data.\nMore input data was expected, but the caller indicated …\nThere is still pending data that didn’t fit in the …\nThe decompressor needs more input data to continue …\nReturn status codes.\nStreaming decompression functionality.\nDecompress one or more source slices from an iterator into …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nExtra streaming decompression functionality.\nMain decompression struct.\nReturns the adler32 checksum of the currently decompressed …\nReturns the adler32 that was read from the zlib header if …\nMain decompression function. Keeps decompressing data from …\nCreate a new tinfl_decompressor with all fields set to 0.\nReturns the argument unchanged.\nFlags to <code>decompress()</code> to control how inflation works.\nSet the current state to <code>Start</code>.\nCalls <code>U::from(self)</code>.\nCreate a new tinfl_decompressor with all fields set to 0.\nCalculate the adler32 checksum of the output data even if …\nThere will be more input that hasn’t been given to the …\nIgnore adler32 checksum even if we are inflating a zlib …\nShould we try to parse a zlib header?\nThe output buffer should not wrap around.\nFull reset of the state, including zeroing memory.\nA struct that compbines a decompressor with extra data for …\nResets state, without performing expensive ops (e.g. …\nTag that determines reset policy of InflateState\nResets state and zero memory, continuing to use the same …\nAccess the innner decompressor.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTry to decompress from <code>input</code> to <code>output</code> with the given …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the status of the last call to <code>inflate</code> with this …\nCreate a new state.\nPerforms reset\nReset the decompressor without re-allocating memory, using …\nResets the state according to specified policy.")