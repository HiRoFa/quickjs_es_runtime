searchState.loadedDescShard("regress", 0, "regress - REGex in Rust with EcmaScript Syntax\nAn iterator type which yields <code>Match</code>es found in a string, …\nRepresents an error encountered during regex compilation.\nFlags used to control regex parsing. The default flags are …\nAn iterator over the capture groups of a <code>Match</code>\nA Match represents a portion of a string which was found …\nAn iterator type which yields <code>Match</code>es found in a string.\nAn iterator over the named capture groups of a <code>Match</code>\nRange is used to express the extent of a match, as indexes …\nA Regex is the compiled version of a pattern.\nReturns the matched text as a string slice.\nThe list of captures. This has length equal to the number …\nIf set, . matches at line separators as well as any other …\nReturns the ending byte offset of the match in the …\nThe upper bound of the range (exclusive).\nEscapes all special regex characters in a string to make …\nSearches <code>text</code> to find the first match.\nSearches <code>text</code> to find the first match. The input text is …\nReturns an iterator for matches found in ‘text’ …\nReturns an iterator for matches found in ‘text’ …\nSearches <code>text</code>, returning an iterator over non-overlapping …\nSearches <code>text</code>, returning an iterator over non-overlapping …\nConstruct a Flags from a string, using JavaScript field …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAttempts to parse a string into a regular expression\nConstruct a regex by parsing <code>pattern</code> with <code>flags</code>, where …\nAccess a group by index, using the convention of Python’…\nReturn an iterator over a Match. The first returned value …\nIf set, make the regex case-insensitive. Equivalent to the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf set, ^ and $ match at line separators, not just the …\nAccess a named group by name.\nReturn an iterator over the named groups of a Match.\nConstruct a Flags from a Unicode codepoints iterator, …\nConstruct a regex by parsing <code>pattern</code> using the default …\nIf set, disable regex IR passes.\nReturns the range over the starting and ending byte …\nThe total range of the match. Note this may be empty, if …\nReplaces the first match of the regex in <code>text</code> with the …\nReplaces all matches of the regex in <code>text</code> with the …\nReplaces all matches of the regex in <code>text</code> using a closure.\nReplaces the first match of the regex in <code>text</code> using a …\nReturns the starting byte offset of the match in the …\nThe lower bound of the range (inclusive).\nIf set, the regex is interpreted as a Unicode regex. …\nIf set, the regex is interpreted as a UnicodeSets regex. …\nConstruct a regex by parsing <code>pattern</code> with <code>flags</code>. An Error …")